/* -*- C -*- 

   @PROLOGUE@

   ----- 

   Jeffrey Vetter vetter3@llnl.gov
   Center for Applied Scientific Computing, LLNL
   12 Aug 2001

   mpiPi.h -- internal mpiP header

*/

#ifndef _MPIPI_H
#define _MPIPI_H

#include <assert.h>
#include <malloc.h>
#include <math.h>
#include <setjmp.h>
#include <stdio.h>
#include <stdlib.h>
#include <strings.h>
#include <sys/time.h>
#include <time.h>
#include <unistd.h>

#ifndef CEXTRACT
#include <mpi.h>
#endif

#include "mpiP-hash.h"

#include "mpiPi_def.h"
#include "mpiPconfig.h"
#include "_timers.h"

#define MPIPI_HOSTNAME_LEN_MAX 128
#define MPIP_CALLSITE_STACK_DEPTH_MAX @STACKDEPTH@

#define MPIP_CALLSITE_STACK_DEPTH (mpiPi.stackDepth)
#define MPIP_CALLSITE_STATS_COOKIE 518641
#define MPIP_CALLSITE_STATS_COOKIE_ASSERT(f) {assert(MPIP_CALLSITE_STATS_COOKIE==((f)->cookie));}

typedef struct _callsite_stats
{
  unsigned op;
  unsigned rank;
  int csid;
  long long count;
  double cumulativeTime;
  double cumulativeTimeSquared;
  double maxDur;
  double minDur;
  double maxDataSent;
  double minDataSent;
  double maxIO;
  double minIO;
  double cumulativeDataSent;
  double cumulativeIO;
  long long arbitraryMessageCount; 
  double *siteData;
  int siteDataIdx;
  void *pc[MPIP_CALLSITE_STACK_DEPTH_MAX];
  char *filename[MPIP_CALLSITE_STACK_DEPTH_MAX];
  char *functname[MPIP_CALLSITE_STACK_DEPTH_MAX];
  int lineno[MPIP_CALLSITE_STACK_DEPTH_MAX];
  long cookie;
}
callsite_stats_t;

typedef struct callsite_src_id_cache_entry_t
{
  int id;			/* unique id for this src code/stack location */
  int op;			/* at the lowest level, this is a MPI op */
  char *filename[MPIP_CALLSITE_STACK_DEPTH_MAX];
  char *functname[MPIP_CALLSITE_STACK_DEPTH_MAX];
  int line[MPIP_CALLSITE_STACK_DEPTH_MAX];
  void *pc[MPIP_CALLSITE_STACK_DEPTH_MAX];
}
callsite_src_id_cache_entry_t;

extern h_t *callsite_src_id_cache;


typedef struct _mpiPi_task_info_t
{
  /* this section is calculated at the collector */
  double mpi_time;

  /* this section is received from each task */
  double app_time;		/* time from end of init to start of finalize */
  int rank;
  char hostname[MPIPI_HOSTNAME_LEN_MAX];

}
mpiPi_task_info_t;

typedef struct _mpiPi_lookup_t
{
  int op;
  char *name;
}
mpiPi_lookup_t;

extern mpiPi_lookup_t mpiPi_lookup[];

enum { MPIP_MPI_TIME_FMT, MPIP_MPI_TIME_SUMMARY_FMT,
       MPIP_AGGREGATE_TIME_FMT, MPIP_AGGREGATE_COV_TIME_FMT,
       MPIP_AGGREGATE_MESS_FMT, MPIP_AGGREGATE_IO_FMT,
       MPIP_CALLSITE_TIME_SUMMARY_FMT, MPIP_CALLSITE_TIME_RANK_FMT, 
       MPIP_CALLSITE_MESS_SUMMARY_FMT, MPIP_CALLSITE_MESS_RANK_FMT,
       MPIP_CALLSITE_IO_SUMMARY_FMT, MPIP_CALLSITE_IO_RANK_FMT
};

typedef enum { MPIP_REPORT_SCI_FORMAT, MPIP_REPORT_FLT_FORMAT } 
  MPIP_REPORT_FORMAT_TYPE;

typedef struct _mpiPi_t
{
  int ac;
  char *av[32];
  char *toolname;
  char *appName;
  char *appFullName;
  char oFilename[256];
  MPI_Comm comm;
  int tag;
  int procID;
  int rank;
  int size;
  int collectorRank;
  char hostname[MPI_MAX_PROCESSOR_NAME];
  int hostnamelen;
  char *outputDir;
  char *envStr;
  FILE *stdout_;
  FILE *stderr_;
  mpiPi_TIME startTime;
  mpiPi_TIME endTime;

  double cumulativeTime; /* necessary for pcontrol */
  time_t start_timeofday;
  time_t stop_timeofday;

  /* pcontrol */
  int enabled;
  int enabledCount;

  mpiPi_TIMER timer;
  mpiPi_task_info_t *global_task_info;
  double global_app_time;
  double global_mpi_time;
  double global_mpi_size;
  double global_mpi_io;
  long long global_mpi_msize_threshold_count;
  long long global_mpi_sent_count;

  int tableSize;
  h_t *task_callsite_stats;
  callsite_stats_t *rawCallsiteData;
  h_t *global_callsite_stats;
  h_t *global_callsite_stats_agg;

  mpiPi_lookup_t *lookup;

  int stackDepth;
  double reportPrintThreshold;
  int baseNames;
  MPIP_REPORT_FORMAT_TYPE reportFormat;
  int calcCOV;
  int do_lookup;
  int inAPIrtb;
  int messageCountThreshold;
  long text_start;
  int obj_mode;
  int allocCount;
  long allocSize;
  int printRankInfo;
}
mpiPi_t;

extern mpiPi_t mpiPi;

extern int mpiPi_vmajor;
extern int mpiPi_vminor;
extern int mpiPi_vpatch;
extern char *mpiPi_vdate;
extern char *mpiPi_vtime;

extern int mpiPi_debug;
extern int mpiPi_do_demangle;

#ifdef HAVE_MPIR_TOPOINTER
extern void *MPIR_ToPointer( int idx );
#endif

#if !defined(UNICOS_mp) 

/*  AIX  */
#if defined(AIX)

#if defined(__64BIT__)  /*  64-bit AIX  */
#define ParentFP(jb) ((void *) *(long *) jb[5])
#else  /*  32-bit AIX  */
#define ParentFP(jb) ((void *) *(long *) jb[3])
#endif

/*  For both 32-bit and 64-bit AIX  */
#define FramePC(fp) ((void *) *(long *) (((long) fp) + (2 * sizeof (void *)))) 
#define NextFP(fp) ((void *) *(long *) fp)

/*  IA32 Linux  */
#elif defined(Linux) && defined(IA32)
#define ParentFP(jb) ((void*) jb[0].__jmpbuf[3])
#define FramePC(fp) ((void*)(((void**)fp)[1]))
#define NextFP(fp) ((void*)((void**)fp)[0])

/*  X86_64 Linux  */
#elif defined(Linux) && defined(X86_64)
#define ParentFP(jb) ((void*) jb[0].__jmpbuf[1])
#define FramePC(fp) ((void*)(((void**)fp)[1]))
#define NextFP(fp) ((void*)((void**)fp)[0])

/*  BG/L  */
#elif defined(ppc64)
#define ParentFP(jb) NextFP(((void*)jb[0].__jmpbuf[0]))
#define FramePC(fp) ((void*)(((char**)fp)[1]))
#define NextFP(fp) ((void*)((char**)fp)[0])

/* Catamount */
#elif defined(Catamount) && defined(X86_64)
#define ParentFP(jb) ((void*) jb[0].__jmpbuf[1])
#define FramePC(fp) ((void*)(((void**)fp)[1]))
#define NextFP(fp) ((void*)((void**)fp)[0])

/*  undefined  */
#else  
#if ! defined(HAVE_LIBUNWIND)
#warning "No stack trace mechanism defined for this platform."
#endif
#define ParentFP(jb) (0)
#define FramePC(fp) (0)
#define NextFP(fp) (0)
#endif

#else /* defined(UNICOS_mp) */

#include <intrinsics.h>
#include <stdint.h>

/*
 * Cray X1
 * Stacks grow downward in the address space.
 */


/*
 * Unlike some of the other platforms, we do not use setjmp to obtain
 * the frame pointer of the current function.  Instead, we use the
 * Cray intrinsic function _read_fp() to get the frame pointer of the 
 * current function.
 */
#define GetFP()    ((void*)(_read_fp()))


/* 
 * Given a frame pointer for a callee, the caller's frame pointer is at the 
 * callee's frame pointer address.
 */
#define NextFP(fp)      ((void*)((void**)fp)[0])


/*
 * Given a frame pointer for a callee, the return address to the caller
 * is two elements in the callee's frame.

 * TODO try masking off the high 32-bits
 */
#define FramePC(fp)     ((void*)(((uint64_t)(((void**)fp)[-2])) & 0xFFFFFFFF))


#endif /* defined(UNICOS_mp) */


#define min(x,y) ((x<y)?(x):(y))
#define max(x,y) ((x>y)?(x):(y))

#include "mpiPi_proto.h"

#endif

/* eof */
